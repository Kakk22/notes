# Redis 重点问题

##  过期策略

**过期集合**

`Redis`会将设置了过期时间的key放入一个独立的字典中，然后会定时遍历字典来删除过期的key。

除了定时遍历外，还会使用**惰性策略**来删除过期的key。惰性策略即当客户端访问这个key时，检查是否过期，如果过期则删除。

**定时扫描策略**

`Redis`默认10秒进行一次过期扫描。过期扫描不会扫描字典中所有的key，而是采用一种简单的**贪心策略**：

1. 从过期字典中随机选出20个key
2. 删除20个key中过期的key
3. 如果过期的key的比例超过1/4 则重复步骤1

同时为了保证过期扫描不会出现循环过度，算法增加了扫描上线为`25ms`

如果大量的key同时过期，则会因为过期扫描出现读写请求明显的卡顿现象。所以在开发过程中，要给过期时间设置一个随机范围

```java
//在目标过期时间上增加一天的随机数
redis.expire(key,random.randint(86400)+expireTime);
```



## 淘汰策略

当`Redis`内存超过物理内存限制时，内存数据会开始和磁盘产生频繁的交换。交换会让`Redis`性能急剧下降。

生产环境中我们不允许出现交换行为，为了限制最大使用内存，`Redis`提供配置参数`maxmemory`来限制内存超出期望大小。

当内存超过`maxmemory`时，`Redis`提供几种淘汰策略：

1. `noeviction`：不会继续服务写请求（`del`请求可以继续服务），读请求可以继续。这也可以保证不会丢失数据，但会让线上的业务不能持续进行。这是**默认**的淘汰策略。
2. `volatile-lru`：尝试淘汰设置了过期时间的key，最少使用的key优先被淘汰。没有设置过期时间的key不会淘汰，这样可以保证需要持久化的数据不会突然丢失。
3. `volatile-ttl`：跟上面几乎一样，不过淘汰策略不是`LRU`，而是比较Key的剩余寿命`ttl`的值，`ttl`越小越优先被淘汰。
4. `volatile-random`：跟上面几乎一样，不过淘汰的key是过期key集合中随机的key
5. `allkeys-lru`：区别于`volatile-lru`，这个策略要淘汰的key对象是全体的key集合，而不只是过期key集合。这意味着一些没有设置过期时间的key也会被淘汰。
6. `allkeys-random`：跟上面几乎一样，不过淘汰的key是随机的key。

`volatile-xxx`策略只会针对过期时间的key进行淘汰，`allkeys-xxx`策略会对所有的key进行淘汰。如果只拿`Redis`作缓存，则应使用`allkeys-xxx`策略。如果同时使用`Redis`的持久化功能，那应该使用`volatile-xxx`策略。