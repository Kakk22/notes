# 第二季笔记

## 案例一：CAS

`CAS`全称为比较并交换（compare and swap ）

在`AtomicInteger`中 变量值用`volatile`修饰

修改变量时 使用自选锁去修改

底层用到的是`Unsafe`类的`native`本地方法

![image-20210120090215725](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210120090215725.png)

`CAS`引发的`ABA`问题可以使用`AtomicStampedReference`解决，即添加一个版本号

## 案例二：公平锁和非公平锁

ReentrantLock 默认为非公平锁

```java
    public ReentrantLock() {
        sync = new NonfairSync();
    }
```

Synchronized 也为非公平锁

**公平锁：**在并发环境中，每个线程获取锁会先查看此锁维护的等待队列，如果为空，或者当前线程时等待队列的第一个，就占有锁。否作加入等待队列中。FIFO先进先出。

**非公平锁：**一开始就尝试占有锁，如果尝试失败，再采取类似公平锁的方式。

## 案例三：可重入锁

 **可重入锁**（也叫递归锁） ReentrantLock Synchronized 都是可重入锁。

指的是 线程可以进入任何一个它已经拥有的锁所同步着的代码块。

可重入锁最大的作用是**避免死锁**

## **案例四：自旋锁**

**自旋锁**即在获取不到锁时不会发生阻塞，而会一直循环尝试获取锁

好处是减少线程上下文切换的消耗

缺点是循环消耗CPU资源

![image-20210123092902491](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210123092902491.png)

UnSafe的getAndAddInt就是自旋锁。获取不到锁会一直循环



```java
/**
 * 自旋锁案例
 *
 * @author 陈一锋
 * @date 2021/1/23 9:40
 **/
public class SpinLockDemo {

    /**
     * 原子引用线程
     */
    private AtomicReference<Thread> atomicReference = new AtomicReference<>();


    public void lock() {
        Thread thread = Thread.currentThread();
        while (!atomicReference.compareAndSet(null, thread)) {
            System.out.println(thread.getName() + "没有获取到锁,一直自旋继续获取");
        }
        System.out.println(thread.getName() + "获取到锁");
    }

    public void unLock() {
        Thread thread = Thread.currentThread();
        atomicReference.compareAndSet(thread, null);
        System.out.println(thread.getName() + "解锁");
    }


    public static void main(String[] args) {
        SpinLockDemo spinLockDemo = new SpinLockDemo();
        new Thread(() -> {
            spinLockDemo.lock();
            //获取锁后睡眠1秒
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            spinLockDemo.unLock();
        }, "AA").start();

        //主线程休眠1秒
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            spinLockDemo.lock();
            spinLockDemo.unLock();
        }, "BB").start();
    }
}

```

## **案例五：**堵塞队列

堵塞队列：

- 当堵塞队列是空的时候，从队列中获取元素会被堵塞。
- 当堵塞队列是满的时候，从队列中添加元素会被堵塞。

![image-20210124102038180](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210124102038180.png)

组织架构：

![image-20210124103130069](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210124103130069.png)

**常见的堵塞队列：**

1. ArrayBlockingQueue：由数组结构组成的有界堵塞队列。
2. LinkedBlockingQueue：由链表结构组成的有界堵塞队列。
3. SynchronousQueue: 不存储元素的堵塞队列，即单个元素的队列（存一个取一个，队列中永远只有一个）。



API 使用

ArrayBlockingQueue使用

```java
package com.cyf.blockingqueue;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * 数组结构堵塞队列
 *
 * @author 陈一锋
 * @date 2021/1/24 10:47
 **/
public class ArrayBlockingQueueDemo {

    public static void main(String[] args) {
        System.out.println("addAndRemove()----");
        //超出会报异常
        addAndRemove();
        System.out.println("offerAndPoll()----");
        //超出返回false
        offerAndPoll();
        System.out.println("pullAndTask()----");
        pullAndTask();
        System.out.println("timeoutOffer()----");
        timeoutOffer();
    }



    private static void addAndRemove() {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
        //add 超过元素会抛出异常
        System.out.println(blockingQueue.add("1"));
        System.out.println(blockingQueue.add("2"));
        System.out.println(blockingQueue.add("3"));

        //抛出异常
        //System.out.println(blockingQueue.add("4"));

        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        // java.util.NoSuchElementException
        //System.out.println(blockingQueue.remove());
    }

    private static void offerAndPoll() {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.offer("1"));
        System.out.println(blockingQueue.offer("2"));
        System.out.println(blockingQueue.offer("3"));
        // 会返回false 不会报错
        System.out.println(blockingQueue.offer("4"));

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        // 没有元素 返回null
        System.out.println(blockingQueue.poll());
    }

    private static void pullAndTask() {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
        try {
            blockingQueue.put("1");
            blockingQueue.put("1");
            blockingQueue.put("1");
            System.out.println("put了3个");
            // blockingQueue.put("1");

            blockingQueue.take();
            blockingQueue.take();
            blockingQueue.take();
            // 这里会阻塞
            //blockingQueue.take();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void timeoutOffer() {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        try {
            blockingQueue.offer("1",2,TimeUnit.SECONDS);
            blockingQueue.offer("1",2,TimeUnit.SECONDS);
            blockingQueue.offer("1",2,TimeUnit.SECONDS);
            blockingQueue.offer("1",2,TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

SynchronousQueue：

```java
package com.cyf.blockingqueue;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

/**
 * 同步堵塞队列
 * 生产一个消费一个
 *
 * @author 陈一锋
 * @date 2021/1/24 11:43
 **/
public class SynchronousQueueDemo {
    public static void main(String[] args) {
        BlockingQueue<String> blockingQueue = new SynchronousQueue<>();

        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName() + "\t put 1");
                blockingQueue.put("1");
                System.out.println(Thread.currentThread().getName() + "\t put 2");
                blockingQueue.put("2");
                System.out.println(Thread.currentThread().getName() + "\t put 3");
                blockingQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "AAA").start();

        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName() + " task " + blockingQueue.take());

                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName() + " task " + blockingQueue.take());

                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName() + " task " + blockingQueue.take());

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "BBB").start();
    }
}

```

## 案例六：生产者消费者模型

使用

Lock及Condition的await和singnal

代替

synchronized和wait跟notify

```java
package com.cyf;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 线程生产者消费者模型
 * 题目:一个初始值为0的变量，两个线程对其进行交替操作，一个+1,一个-1, 一共5轮
 * 1、线程 操作 资源类
 * 2、判断 干活 通知
 * 3、防止虚假唤醒 多线程判断用while
 *
 * @author 陈一锋
 * @date 2021/1/24 12:02
 **/
public class ProducerAndConsumer {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                data.increment();
            }
        },"AAA").start();

        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                data.decrement();
            }
        },"BBB").start();
    }
}


/**
 * 资源类
 */
class Data {
    private int i;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void increment() {
        lock.lock();
        try {
            //1.判断
            while (i != 0) {
                //2.等待不能生产
                condition.await();
            }
            //3.操作
            i++;
            System.out.println(Thread.currentThread().getName() + "\t 操作后i值" + i);
            //4.唤醒
            condition.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void decrement() {
        lock.lock();
        try {
            while (i == 0) {
                //等待不能消费
                condition.await();
            }
            i--;
            System.out.println(Thread.currentThread().getName() + "\t 操作后i值" + i);
            //唤醒
            condition.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

## **案例七：**synchronized和Lock的区别

synchronized和Lock的区别

1. synchronized是**JVM关键字**，其底层实现是通过对象锁**monitorenter**和**monitorexit**。wait和notify方法也依赖于monitor对象，只有在同步块或方法中才能调用wait和notify。而**Lock**是**api层面上的锁**。
2. 使用方法。synchronized是不需要手动释放锁的。当执行完synchronized代码块系统会自动释放锁。而Lock需要手动释放锁，否作会出现死锁现象。
3. synchronized不可中断。除非抛出异常或正常运行结束。ReentrantLock是可中断的。tryLock(long timeout,TimeUtil unit)
4. 加锁是否公平。synchronized 是非公平锁。ReentrantLock既有公平锁也有非公平锁。
5. 锁绑定多个Condition。synchronized没有。Lock可以设置多个锁条件。可以精确唤醒线程。而不像synchronized要么唤醒一个要么唤醒所有。

## 案例八：堵塞队列生产者消费模型

```java
/**
 * 堵塞队列实现生产者消费者模型
 *
 * @author 陈一锋
 * @date 2021/1/24 20:17
 **/
public class BlockingQueueDemo {


    public static void main(String[] args) {

        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(5);

        Pro pro = new Pro(blockingQueue);
        new Thread(() -> pro.produce(), "A").start();
        new Thread(() -> pro.consume(), "B").start();

        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();




        }
        pro.stop();
    }
}

class Pro {
    private volatile boolean flag = true;
    private AtomicInteger atomicInteger = new AtomicInteger();
    private final BlockingQueue<String> blockingQueue;

    Pro(BlockingQueue<String> blockingQueue) {
        this.blockingQueue = blockingQueue;
    }

    public void produce() {
        while (flag) {
            String data = atomicInteger.incrementAndGet() + "";
            boolean result = blockingQueue.offer(data);
            if (result) {
                System.out.println(Thread.currentThread().getName() + "插入数据" + data + "成功");
            }else {
                System.out.println(Thread.currentThread().getName() + "插入数据" + data + "失败");
            }
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(Thread.currentThread().getName() + "\t 收到信息停止生产");
    }

    public void consume() {
        while (flag) {
            try {
                String result = blockingQueue.poll(2, TimeUnit.SECONDS);
                if (result == null || "".equals(result)) {
                    flag = false;
                    System.out.println(Thread.currentThread().getName() + "\t 超过两秒没有收到信息,退出消费");
                }else {
                    System.out.println(Thread.currentThread().getName() + "\t 开始消费");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void stop(){
        this.flag = false;
    }

}

```

