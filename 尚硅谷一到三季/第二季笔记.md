# 第二季笔记

## 案例一：CAS

`CAS`全称为比较并交换（compare and swap ）

在`AtomicInteger`中 变量值用`volatile`修饰

修改变量时 使用自选锁去修改

底层用到的是`Unsafe`类的`native`本地方法

![image-20210120090215725](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210120090215725.png)

`CAS`引发的`ABA`问题可以使用`AtomicStampedReference`解决，即添加一个版本号

## 案例二：公平锁和非公平锁

ReentrantLock 默认为非公平锁

```java
    public ReentrantLock() {
        sync = new NonfairSync();
    }
```

Synchronized 也为非公平锁

**公平锁：**在并发环境中，每个线程获取锁会先查看此锁维护的等待队列，如果为空，或者当前线程时等待队列的第一个，就占有锁。否作加入等待队列中。FIFO先进先出。

**非公平锁：**一开始就尝试占有锁，如果尝试失败，再采取类似公平锁的方式。

## 案例三：可重入锁

 **可重入锁**（也叫递归锁） ReentrantLock Synchronized 都是可重入锁。

指的是 线程可以进入任何一个它已经拥有的锁所同步着的代码块。

可重入锁最大的作用是**避免死锁**