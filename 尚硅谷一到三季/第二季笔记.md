# 第二季笔记

## 案例一：CAS

`CAS`全称为比较并交换（compare and swap ）

在`AtomicInteger`中 变量值用`volatile`修饰

修改变量时 使用自选锁去修改

底层用到的是`Unsafe`类的`native`本地方法

![image-20210120090215725](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210120090215725.png)

`CAS`引发的`ABA`问题可以使用`AtomicStampedReference`解决，即添加一个版本号

## 案例二：公平锁和非公平锁

ReentrantLock 默认为非公平锁

```java
    public ReentrantLock() {
        sync = new NonfairSync();
    }
```

Synchronized 也为非公平锁

**公平锁：**在并发环境中，每个线程获取锁会先查看此锁维护的等待队列，如果为空，或者当前线程时等待队列的第一个，就占有锁。否作加入等待队列中。FIFO先进先出。

**非公平锁：**一开始就尝试占有锁，如果尝试失败，再采取类似公平锁的方式。

## 案例三：可重入锁

 **可重入锁**（也叫递归锁） ReentrantLock Synchronized 都是可重入锁。

指的是 线程可以进入任何一个它已经拥有的锁所同步着的代码块。

可重入锁最大的作用是**避免死锁**

## **案例四：自旋锁**

**自旋锁**即在获取不到锁时不会发生阻塞，而会一直循环尝试获取锁

好处是减少线程上下文切换的消耗

缺点是循环消耗CPU资源

![image-20210123092902491](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210123092902491.png)

UnSafe的getAndAddInt就是自旋锁。获取不到锁会一直循环



```java
/**
 * 自旋锁案例
 *
 * @author 陈一锋
 * @date 2021/1/23 9:40
 **/
public class SpinLockDemo {

    /**
     * 原子引用线程
     */
    private AtomicReference<Thread> atomicReference = new AtomicReference<>();


    public void lock() {
        Thread thread = Thread.currentThread();
        while (!atomicReference.compareAndSet(null, thread)) {
            System.out.println(thread.getName() + "没有获取到锁,一直自旋继续获取");
        }
        System.out.println(thread.getName() + "获取到锁");
    }

    public void unLock() {
        Thread thread = Thread.currentThread();
        atomicReference.compareAndSet(thread, null);
        System.out.println(thread.getName() + "解锁");
    }


    public static void main(String[] args) {
        SpinLockDemo spinLockDemo = new SpinLockDemo();
        new Thread(() -> {
            spinLockDemo.lock();
            //获取锁后睡眠1秒
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            spinLockDemo.unLock();
        }, "AA").start();

        //主线程休眠1秒
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(() -> {
            spinLockDemo.lock();
            spinLockDemo.unLock();
        }, "BB").start();
    }
}

```

## **案例五：**堵塞队列

堵塞队列：

- 当堵塞队列是空的时候，从队列中获取元素会被堵塞。
- 当堵塞队列是满的时候，从队列中添加元素会被堵塞。

![image-20210124102038180](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210124102038180.png)

组织架构：

![image-20210124103130069](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210124103130069.png)

**常见的堵塞队列：**

1. ArrayBlockingQueue：由数组结构组成的有界堵塞队列。
2. LinkedBlockingQueue：由链表结构组成的有界堵塞队列。
3. SynchronousQueue: 不存储元素的堵塞队列，即单个元素的队列（存一个取一个，队列中永远只有一个）。



API 使用

ArrayBlockingQueue使用

```java
package com.cyf.blockingqueue;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * 数组结构堵塞队列
 *
 * @author 陈一锋
 * @date 2021/1/24 10:47
 **/
public class ArrayBlockingQueueDemo {

    public static void main(String[] args) {
        System.out.println("addAndRemove()----");
        //超出会报异常
        addAndRemove();
        System.out.println("offerAndPoll()----");
        //超出返回false
        offerAndPoll();
        System.out.println("pullAndTask()----");
        pullAndTask();
        System.out.println("timeoutOffer()----");
        timeoutOffer();
    }



    private static void addAndRemove() {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
        //add 超过元素会抛出异常
        System.out.println(blockingQueue.add("1"));
        System.out.println(blockingQueue.add("2"));
        System.out.println(blockingQueue.add("3"));

        //抛出异常
        //System.out.println(blockingQueue.add("4"));

        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        // java.util.NoSuchElementException
        //System.out.println(blockingQueue.remove());
    }

    private static void offerAndPoll() {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.offer("1"));
        System.out.println(blockingQueue.offer("2"));
        System.out.println(blockingQueue.offer("3"));
        // 会返回false 不会报错
        System.out.println(blockingQueue.offer("4"));

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        // 没有元素 返回null
        System.out.println(blockingQueue.poll());
    }

    private static void pullAndTask() {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);
        try {
            blockingQueue.put("1");
            blockingQueue.put("1");
            blockingQueue.put("1");
            System.out.println("put了3个");
            // blockingQueue.put("1");

            blockingQueue.take();
            blockingQueue.take();
            blockingQueue.take();
            // 这里会阻塞
            //blockingQueue.take();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    private static void timeoutOffer() {
        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        try {
            blockingQueue.offer("1",2,TimeUnit.SECONDS);
            blockingQueue.offer("1",2,TimeUnit.SECONDS);
            blockingQueue.offer("1",2,TimeUnit.SECONDS);
            blockingQueue.offer("1",2,TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

```

SynchronousQueue：

```java
package com.cyf.blockingqueue;

import java.util.concurrent.BlockingQueue;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

/**
 * 同步堵塞队列
 * 生产一个消费一个
 *
 * @author 陈一锋
 * @date 2021/1/24 11:43
 **/
public class SynchronousQueueDemo {
    public static void main(String[] args) {
        BlockingQueue<String> blockingQueue = new SynchronousQueue<>();

        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName() + "\t put 1");
                blockingQueue.put("1");
                System.out.println(Thread.currentThread().getName() + "\t put 2");
                blockingQueue.put("2");
                System.out.println(Thread.currentThread().getName() + "\t put 3");
                blockingQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "AAA").start();

        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName() + " task " + blockingQueue.take());

                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName() + " task " + blockingQueue.take());

                TimeUnit.SECONDS.sleep(2);
                System.out.println(Thread.currentThread().getName() + " task " + blockingQueue.take());

            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "BBB").start();
    }
}

```

## 案例六：生产者消费者模型

使用

Lock及Condition的await和singnal

代替

synchronized和wait跟notify

```java
package com.cyf;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 线程生产者消费者模型
 * 题目:一个初始值为0的变量，两个线程对其进行交替操作，一个+1,一个-1, 一共5轮
 * 1、线程 操作 资源类
 * 2、判断 干活 通知
 * 3、防止虚假唤醒 多线程判断用while
 *
 * @author 陈一锋
 * @date 2021/1/24 12:02
 **/
public class ProducerAndConsumer {
    public static void main(String[] args) {
        Data data = new Data();

        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                data.increment();
            }
        },"AAA").start();

        new Thread(()->{
            for (int i = 0; i < 5; i++) {
                data.decrement();
            }
        },"BBB").start();
    }
}


/**
 * 资源类
 */
class Data {
    private int i;
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void increment() {
        lock.lock();
        try {
            //1.判断
            while (i != 0) {
                //2.等待不能生产
                condition.await();
            }
            //3.操作
            i++;
            System.out.println(Thread.currentThread().getName() + "\t 操作后i值" + i);
            //4.唤醒
            condition.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void decrement() {
        lock.lock();
        try {
            while (i == 0) {
                //等待不能消费
                condition.await();
            }
            i--;
            System.out.println(Thread.currentThread().getName() + "\t 操作后i值" + i);
            //唤醒
            condition.signal();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```

## **案例七：**synchronized和Lock的区别

synchronized和Lock的区别

1. synchronized是**JVM关键字**，其底层实现是通过对象锁**monitorenter**和**monitorexit**。wait和notify方法也依赖于monitor对象，只有在同步块或方法中才能调用wait和notify。而**Lock**是**api层面上的锁**。
2. 使用方法。synchronized是不需要手动释放锁的。当执行完synchronized代码块系统会自动释放锁。而Lock需要手动释放锁，否作会出现死锁现象。
3. synchronized不可中断。除非抛出异常或正常运行结束。ReentrantLock是可中断的。tryLock(long timeout,TimeUtil unit)
4. 加锁是否公平。synchronized 是非公平锁。ReentrantLock既有公平锁也有非公平锁。
5. 锁绑定多个Condition。synchronized没有。Lock可以设置多个锁条件。可以精确唤醒线程。而不像synchronized要么唤醒一个要么唤醒所有。

## 案例八：堵塞队列生产者消费模型

```java
/**
 * 堵塞队列实现生产者消费者模型
 *
 * @author 陈一锋
 * @date 2021/1/24 20:17
 **/
public class BlockingQueueDemo {


    public static void main(String[] args) {

        BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(5);

        Pro pro = new Pro(blockingQueue);
        new Thread(() -> pro.produce(), "A").start();
        new Thread(() -> pro.consume(), "B").start();

        try {
            TimeUnit.SECONDS.sleep(5);
        } catch (InterruptedException e) {
            e.printStackTrace();




        }
        pro.stop();
    }
}

class Pro {
    private volatile boolean flag = true;
    private AtomicInteger atomicInteger = new AtomicInteger();
    private final BlockingQueue<String> blockingQueue;

    Pro(BlockingQueue<String> blockingQueue) {
        this.blockingQueue = blockingQueue;
    }

    public void produce() {
        while (flag) {
            String data = atomicInteger.incrementAndGet() + "";
            boolean result = blockingQueue.offer(data);
            if (result) {
                System.out.println(Thread.currentThread().getName() + "插入数据" + data + "成功");
            }else {
                System.out.println(Thread.currentThread().getName() + "插入数据" + data + "失败");
            }
            try {
                TimeUnit.SECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(Thread.currentThread().getName() + "\t 收到信息停止生产");
    }

    public void consume() {
        while (flag) {
            try {
                String result = blockingQueue.poll(2, TimeUnit.SECONDS);
                if (result == null || "".equals(result)) {
                    flag = false;
                    System.out.println(Thread.currentThread().getName() + "\t 超过两秒没有收到信息,退出消费");
                }else {
                    System.out.println(Thread.currentThread().getName() + "\t 开始消费");
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void stop(){
        this.flag = false;
    }

}

```

## 案例九：常用的线程池及线程池参数设置

`java`中的线程池框架图

![image-20210126194736908](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210126194736908.png)

线程池都是`ExecutorService`的实现类

`Executors`为创建线程池的工具类

案例：

```java

/**
 * 线程池案例
 *
 * @author 陈一锋
 * @date 2021/1/25 22:37
 **/
public class ThreadPoolDemo {
    public static void main(String[] args) throws InterruptedException {
        //固定线程数的线程池
        ExecutorService ThreadPool = Executors.newFixedThreadPool(5);
        //单个线程的线程池
        //ExecutorService ThreadPool = Executors.newSingleThreadExecutor();
        //带缓存的线程池
        //ExecutorService ThreadPool = Executors.newCachedThreadPool();
        try {
            for (int i = 0; i < 10; i++) {
                ThreadPool.execute(() -> System.out.println(Thread.currentThread().getName() + "处理业务"));
                TimeUnit.MICROSECONDS.sleep(200);
            }
        } finally {
            //关闭线程池
            ThreadPool.shutdown();
        }
    }
}

```

### ThreadPoolExecutor 线程池的构造参数

```java
    /**
     * @param corePoolSize    线程池中的常驻核心线程数
     * @param maximumPoolSize 线程池能够容纳同时执行的最大线程数,此值必须大于等于1
     * @param keepAliveTime   多余的空闲线程存活的时间。当前线程池数量超过corePoolSize时,当空闲时间达到keepAliveTime值时,多余空闲线程会被销毁直到只剩下corePoolSize
     *                        个线程为止
     * @param unit            KeepAliveTime 单位
     * @param workQueue       任务队列,被提交但未被执行的任务
     * @param threadFactory   表示生成线程池中工作线程的线程工厂
     * @param handler         拒绝策略。表示当队列满了并且工作线程大于等于线程池的最大线程数
     */
    public ThreadPoolExecutor(int corePoolSize,
                              int maximumPoolSize,
                              long keepAliveTime,
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler)
```

###  **线程池流程**

![image-20210126203650906](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20210126203650906.png)

1. 创建线程池，等待提交过来的任务请求

2. 当调用**execute()**方法添加一个请求任务时，线程池会做如下判断：

   2.1 如果正在运行的线程数量小于**corePoolSize**，那么马上创建线程运行这个任务

   2.2 如果正在运行的线程数量大于或等于**corePoolSize**，那么将这个任务放入队列

   2.3 如果这个时候队列满了且正在运行的线程数量还小于**maximumPoolSize**，那么还是创建非核心线程数立	   即运行这个任务；

   2.4 如果队列满了且正在运行的线程数量大于或者等于**maximumPoolSize**，那么线程池会启动饱和拒绝策略	  来执行。

3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。

4. 当一个线程无事可做超过一定的时间（**keepAliveTime**）时，线程池会判断：

   1. 如果当前运行的线程数大于**corePoolSize**，那么这个线程就被停掉
   2. 所以线程池的所有任务完成后它最终会**收缩到corePoolSize的大小**。

### 拒绝策略

1. AbortPolicy(默认)

   ​	超过堵塞队列及最大线程数 报异常

2.  CallerRunsPolicy

   ​	回退到执行线程 执行任务

3. DiscardOldestPolicy

   ​	抛弃队列中等待最久的任务，然后把当前任务加入队列中尝试再起提交当前任务

4. DiscartPolicy

   ​    直接丢弃任务。如果运行任务丢失,这是最好的方案

### 线程池核心参数如何设置

1. CPU密集型

    尽量使用较小的线程池，一般**Cpu核心数+**1。因为CPU密集型任务CPU的使用率很高，若开过多的线程，只能增加线程上下文的切换次数，带来额外的开销

2. IO密集型

   方法一：可以使用较大的线程池，一般**CPU核心数 * 2**

   IO密集型CPU使用率不高，可以让CPU等待IO的时候处理别的任务，充分利用cpu时间

   方法二：线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程

## 案例十：死锁

案例

```java
package com.cyf.thread;

/**
 * @author 陈一锋
 * @date 2021/1/26 21:33
 **/
public class DeadLockDemo {


    public static void main(String[] args) {
        String lockA = "lockA";
        String lockB = "lockB";
        new Thread(new HoldLockThread(lockA,lockB)).start();
        new Thread(new HoldLockThread(lockB,lockA)).start();
    }

}


class HoldLockThread implements Runnable {

    private final String lockA;
    private final String lockB;

    public HoldLockThread(String lockA, String lockB) {
        this.lockA = lockA;
        this.lockB = lockB;
    }


    @Override
    public void run() {
        synchronized (lockA) {
            System.out.println(Thread.currentThread().getName() + "\t持有锁" + lockA + ",尝试获取锁" + lockB);

            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (lockB) {
                System.out.println(Thread.currentThread().getName() + "获取到锁" + lockB);
            }
        }
    }
}
```

解决方法：

使用`jps -l`命令查出线程号

`linux`上使用`ps -ef | grep java | grep -v grep`

```bash
D:\java exercise\framework-learn>jps -l
4832 org.jetbrains.jps.cmdline.Launcher
23652 com.cyf.thread.DeadLockDemo
17964
24412 sun.tools.jps.Jps
```

使用 `jstack 进程号`

jstack 23652

```bash
Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x0000000002d5bd28 (object 0x000000076bb98738, a java.lang.String),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x0000000002d5e508 (object 0x000000076bb98770, a java.lang.String),
  which is held by "Thread-1"

Java stack information for the threads listed above:
===================================================
"Thread-1":
        at com.cyf.thread.HoldLockThread.run(DeadLockDemo.java:42)
        - waiting to lock <0x000000076bb98738> (a java.lang.String)
        - locked <0x000000076bb98770> (a java.lang.String)
        at java.lang.Thread.run(Thread.java:748)
"Thread-0":
        at com.cyf.thread.HoldLockThread.run(DeadLockDemo.java:42)
        - waiting to lock <0x000000076bb98770> (a java.lang.String)
        - locked <0x000000076bb98738> (a java.lang.String)
        at java.lang.Thread.run(Thread.java:748)

Found 1 deadlock.

```

找到死锁位置

## 案例十一：GC ROOT

**可达性分析算法**：从GC ROOT开始，往下一直搜索，如果一个对象到GC ROOT没有任何引用，则说明此对象不可用，被判断为死亡，垃圾搜集器进行回收。

哪些可以作为GC ROOT对象：

1. 虚拟机栈(栈帧中的局部变量表)中引用的对象
2. 方法区中类静态属性引用的对象 
3. 方法区中常用引用的对象
4. 本地方法栈中（Native方法）引用的对象

## 案例十二：XX参数

`jps -l`查看进行进程id

`jinfo -flag 参数 进程id ` 查询JVM参数

```bash
D:\java exercise\framework-learn>jps -l
36064 sun.tools.jps.Jps
23652 com.cyf.thread.DeadLockDemo
17032 com.cyf.gc.xx.XXArgs
4712 org.jetbrains.jps.cmdline.Launcher
17964

D:\java exercise\framework-learn>jinfo -flag PrintGCDetails 17032
-XX:-PrintGCDetails
# -号代表启动没有这个参数
```



`jinfo -flags 进程id`

查看JVM所有参数



-Xms 等价于 -XX:InitialHeapSize=31457280  

-Xmx 等价于 -XX:MaxHeapSize=482344960 



### 查看参数盘点家底

java -XX:+PrintFlagsInitial 查看出厂设置

java -XX:+PrintFlagsFinal 查看修改后的参数

