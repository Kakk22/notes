# 1、设计模式七大原则

**设计模式体现了代码的耦合性， 内聚性以及可维护性，可扩展性，重用性，灵活性。**

- **1、代码重用性（即：相同功能的代码，不用多次编写）**
- **2、可读性（即：编程规范性，便于其他程序员的阅读和理解）**
- **3、可扩展性（即：当需要增加新的功能时，非常的方便，称为可维护）**
- **4、可靠性（即：当我们增加新的功能后，对原来的功能没有影响）**
- **5、使程序呈现`高内聚，低耦合`的特性**

**`Scott Mayers在其巨著《Effective C++》说过: C++老手和C++新手的区别就是前者手背上有很多伤疤。`**

- **同样是面向对象，当然也可指 Java**

## 一、单一职责原则（Single responsibility）

**单一职责原则注意事项和细节：**

- **1、降低类的复杂度，一个类只负责一项职责；**
- **2、提高类的可读性，可维护性；**
- **3、降低变更引起的风险**;
- **4、通常情况下，应当遵守单一职责原则， 只有逻辑足够简单，才可以在方法级违反单一职责原则**。

```java
/**
 * 只有类中方法数量足够少，可以在方法级别保持单一职责原则
 */
public class Singleresponsibility {
    public static void main(String[] args) {
        Vehicle vehicle = new Vehicle();
        vehicle.run("跑跑卡丁车");
        vehicle.fly("直升飞机");
    }
}

//交通工具类
// 逻辑简单，方法级别实现单一职责
// 逻辑复杂，分类实现单一职责
class Vehicle{
    public void run(String vehicle){
        System.out.println(vehicle+"在陆地上跑");
    }
    public void fly(String vehicle){
        System.out.println(vehicle+"在天空上飞");
    }
}
```

##  二、接口隔离原则（Interface Segregation）

- **1、类A通过接口 Interface1、2 依赖类B，类C通过接口 Interface1、3 依赖类D，如果接口 Interface 对于 类A 和 类C 来说不是最小接口，那么 类B 和 类D 必须去实现他们不需要的方法。**
- **2、将接口 Interface 拆分为独立的几个接口，类A 和 类C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。**
- **3、接口 Interface 中出现的方法，根据实际情祝拆分为三个接口。**

![image-20200505134625867](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200505134625867.png)

```java
public class Segregation {
    public static void main(String[] args) {
        A a = new A();
        a.depent1(new B());//A依赖B
        a.depent2(new B());
        a.depent3(new B());
        C c = new C();
        c.depent1(new D());//C依赖D
        c.depent2(new D());
        c.depent3(new D());
    }
}

interface interface1{
    void operation1();
}

interface interface2{
    void operation2();
    void operation3();
}

interface interface3{
    void operation4();
    void operation5();
}

class B implements interface1,interface2{

    @Override
    public void operation1() {
        System.out.println("b实现了operation1");
    }

    @Override
    public void operation2() {
        System.out.println("b实现了operation2");
    }

    @Override
    public void operation3() {
        System.out.println("b实现了operation3");
    }
}

class D implements interface1,interface3{
    @Override
    public void operation1() {
        System.out.println("D实现了operation1");
    }

    @Override
    public void operation4() {
        System.out.println("D实现了operation4");
    }

    @Override
    public void operation5() {
        System.out.println("D实现了operation5");
    }
}

class A{
    void depent1(interface1 i){
        i.operation1();
    }
    void depent2(interface2 i){
        i.operation2();
    }
    void depent3(interface2 i){
        i.operation3();
    }
}
class C{
    void depent1(interface1 i){
        i.operation1();
    }
    void depent2(interface3 i){
        i.operation4();
    }
    void depent3(interface3 i){
        i.operation5();
    }

```

## 三、依赖倒转原则（Dependence Inversion）

- **1、高层模块不应该依赖低层模块，二者都应该依赖其抽象（缓冲层）；**
- **2、抽象不应该依赖细节，细节应该依赖抽象；**
- **3、依赖倒转(倒置)的中心思想是面向接口编程;**
- **4、依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在java中， 抽象指的是接口或抽象类，细节就是具体的实现类；**
- **5、使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。**



- **依赖关系三种传递方式：**
  - **接口传递（依赖）**
  - **构造方法传递（依赖）**
  - **setter方式传递（聚合）**

```java
//依赖倒转原则
public class DependenceInversion {
    public static void main(String[] args) {
        persion persion = new persion();
        persion.receve(new Email());
        persion.receve(new Wechat());
    }
}

interface IRecever{
    String getInfo();
}

class Email implements IRecever{

    @Override
    public String getInfo() {
        return "email:helloworld";
    }
}
class Wechat implements IRecever{

    @Override
    public String getInfo() {
        return "Wechat:helloworld";
    }
}



//模拟人收到消息
class persion{
    //接受类型为接口
    public void receve(IRecever recever){
        String info = recever.getInfo();
        System.out.println(info);
    }
}
```

## 四、里氏替换原则（Liskov Substitution）

- **1、里氏替换原则(Liskov Substitution Principle)在1988年，由麻省理工学院一位姓里的女士提出；**

- **2、如果对每个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。换句话说，所有引用基类的地方必须能透明地使用其子类的对象；**

- **3、在使用继承时，遵循里氏替换原则，`在子类中尽量不要重写父类的方法`；**

- **4、`继承实际上让两个类耦合性增强了，给程序带来侵入性。在适当的情况下，可以通过聚合，组合，依赖来解决问题；`**

- 5、**继承包含这样一层含义：父类中凡是已经实现好的方法，实际上是在设定规范和契约，虽然它不强制要求所有的子类必须遵循这些契约，但是如果子类对这些已经实现的方法任意修改，就会对整个继承体系造成破坏。**

  ```java
  public class LiskovSubstitution {
      public static void main(String[] args) {
          A a = new A();
          System.out.println("2-1=" + a.func1(2, 1));
  
          B b = new B();
          System.out.println("2+1=" + b.func1(2, 1));
          System.out.println("2+1+9=" + b.func2(2, 1));
          System.out.println("B类使用A类方法：2-1=" + b.func3(2, 1));
      }
  }
  
  class Base {
      //把基础方法和成员抽取成基类
      public int func1(int num1, int num2) {
          return num1 - num2;
      }
  }
  
  class A extends Base {
  
  //    public int func1(int num1, int num2) {
  //        return num1 - num2;
  //    }
  }
  
  class B extends Base {
  
        // TODO 类 B `无意` 重写了父类 A 方法，造成原有方法发生改变。
  //    @Override
  //    public int func1(int num1, int num2) {
  //        return num1 + num2;
  //    }
  
      @Override
      public int func1(int num1, int num2) {
          return num1 + num2;
      }
  
      public int func2(int num1, int num2) {
          return func1(num1, num2) + 9;
      }
  
      private A a = new A();//组合
  
      //使用 A 方法
      public int func3(int num1, int num2) {
          return this.a.func1(num1, num2);
      }
  }
  ```





## 五、开闭原则 OCP（Open Closed

- **1、开闭原则(Open Closed Principle) 是编程中最基础、最重要的设计原则；**
- **2、`一个软件实体，比如类，模块和函数应该对提供方扩展开放，对使用方修改关闭。用抽象构建框架，用实现扩展细节；`**
- **3、当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化；**
- **4、编程中遵循其它原则，以及使用设计模式的目的就是遵循开闭原则。**

```java
//开闭原则
public class Ocp {
    public static void main(String[] args) {
        Use use = new Use();
        use.drawShape(new Triangle());
        use.drawShape(new Circle());
        use.drawShape(new OtherGraphics());
    }
}


class Use{
    public void drawShape(Shape shape){
        shape.draw();
    }
}

abstract class  Shape{
    public abstract void draw();
}

class Triangle extends Shape{
    @Override
    public void draw() {
        System.out.println("绘制三角形");
    }
}

class  Circle extends  Shape{
    @Override
    public void draw() {
        System.out.println("绘制圆形");
    }
}
class OtherGraphics extends Shape {

    @Override
    public void draw() {
        System.out.println("子类实现具体功能：任何形状");
    }
}
```

## 六、迪米特法则（Demeter）

- **1、一个对象应该对其他对象保持最少的了解`（最少知道原则 LKP）`。**

- **2、类与类关系越密切，耦合度越大。`要求降低类之间耦合，而不是完全解耦。`**

- **3、迪米特法则(Demeter Principle)，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供public方法，不对外泄露任何信息。**

- **4、迪米特法则更简单的定义：只与直接的朋友通信**。

- **5、直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合 等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。**

  ```java
  class A{
  	B b;//全局变量 - 直接朋友
  	public B m1(){} //方法返回值 - 直接朋友
  	public void m2(B b){}//方法入参 - 直接朋友
  	public void m3(){
  		B b1 = new B();// 局部变量 非直接朋友
  	}
  }
  ```

  ```java
  public class Demeter {
      public static void main(String[] args) {
          SchoolManager schoolManager = new SchoolManager();
          schoolManager.printAllEmployee(new CollegeManager());
      }
  }
  
  //学院员工类
  class CollegeEmployee {
      private String id;
  
      public String getId() {
          return id;
      }
  
      public void setId(String id) {
          this.id = id;
      }
  }
  
  //管理学院员工的管理类:
  class CollegeManager {
      //返回学院的所有员工 //TODO CollegeEmployee 直接朋友
      public List<CollegeEmployee> getAllEmployee() {
          List<CollegeEmployee> list = new ArrayList<CollegeEmployee>();
          for (int i = 0; i < 10; i++) { //这里我们增加了10 个员工到list ，
              CollegeEmployee emp = new CollegeEmployee();
              emp.setId("学院员工id " + i);
              list.add(emp);
          }
          return list;
      }
  
      public void printCollegeEmployee() {
          List<CollegeEmployee> list1 = this.getAllEmployee();
          System.out.println("---学院员工----");
          for (CollegeEmployee e : list1) {
              System.out.println(e.getId());
          }
      }
  }
  
  //学校总部员工类
  class SchoolEmployee {
      private String id;
  
      public String getId() {
          return id;
      }
  
      public void setId(String id) {
          this.id = id;
      }
  }
  
  //学校管理类
  //TODO 直接朋友 Employee CollegeManager
  class SchoolManager {
      //返回学校总部的员工
      public List<SchoolEmployee> getAllEmployee() {
          List<SchoolEmployee> list = new ArrayList<SchoolEmployee>();
          for (int i = 0; i < 5; i++) { //这里我们增加了5个员工到list
              SchoolEmployee emp = new SchoolEmployee();
              emp.setId("学校总部员工id= " + i);
              list.add(emp);
          }
          return list;
      }
  
      //该方法完成输出学校总部和学院员工信息(id)
      void printAllEmployee(CollegeManager sub) {
          //获取到学院员工
          //TODO 非直接朋友 CollegeEmployee  应该提取到  CollegeManager
  //        List<CollegeEmployee> list1 = sub.getAllEmployee();
  //        System.out.println("---学院员工----");
  //        for (CollegeEmployee e : list1) {
  //            System.out.println(e.getId());
  //        }
          sub.printCollegeEmployee();//只提供方法，不把具体实现放在其他类里面。
  
          //获取到学校总部员工
          List<SchoolEmployee> list2 = this.getAllEmployee();
          System.out.println("------学校总部员工------");
          for (SchoolEmployee e : list2) {
              System.out.println(e.getId());
          }
      }
  }
  ```

  

## 七、合成复用原则（Composite Reuse）

**合成复用原则 尽量使用组合/聚合的方式，而不是使用继承。**

- **1、找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。**

- **2、针对接口编程，而不是针对实现编程。**

- **3、为了交互对象之间的松耦合设计而努力**。

- ```java
  public class CompositeReuse {
      public static void main(String[] args) {
          System.out.println("------依赖------");
          B b = new B();
          b.Operation1(new A());
  
          System.out.println("------聚合------");
          b.setA(new A());
          b.Operation2();
  
          System.out.println("------组合------");
          b.Operation3();
      }
  }
  
  class A {
      void Operation1() {
          System.out.println("A Operation1");
      }
  
      void Operation2() {
          System.out.println("A Operation2");
      }
  
      void Operation3() {
          System.out.println("A Operation3");
      }
  }
  
  //如果只是需要用到 A类的方法，尽量不要使用继承。而是使用，依赖，聚合，组合的方式
  class B {
      void Operation1(A a) {//TODO 依赖
          a.Operation1();
          a.Operation2();
          a.Operation3();
      }
  
      //==============================================================
      A a;
      public void setA(A a) {
          this.a = a;
      }
  
      void Operation2() {//TODO 聚合
          a.Operation1();
          a.Operation2();
          a.Operation3();
      }
  
      //==============================================================
      A a1 = new A();
  
      void Operation3() {//TODO 组合
          a1.Operation1();
          a1.Operation2();
          a1.Operation3();
      }
  }
  ```

  总结一下，依赖是传入参数，聚合是通过set注入，组合是再类里new一个实例。



# 2、UML

**IDEA PlantUML表示类与类之间的关系的符号**

```java
@startuml

Class1 <|-- ClassA:泛化
Class2 <-- ClassB:关联
Class3 *-- ClassC:组合
Class4 o-- ClassD:聚合
Class5 <|.. ClassE:实现
Class6 <.. ClassF:依赖

@enduml
```



![image-20200505172459261](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200505172459261.png)

### 1、依赖（Dependence）

**只要是在类中用到了对方，那么他们之间就存在依赖关系。如果没有对方，连编绎都通过不了。**

- **类中用到了对方；**

- **类的成员属性；**

- **方法的返回类型；**

- **方法接收的参数类型；**

- **方法中使用到**。

- ![image-20200505174608185](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200505174608185.png)

  ```java
  /**
   * 类中用到了对方；
   * 类的成员属性；
   * 方法的返回类型；
   * 方法接收的参数类型；
   * 方法中使用到；
   */
  public class Dependence {
      A a;//TODO 类的成员属性
  
      public A save(B b) {//TODO 方法接收的参数类型
          //TODO 方法的返回类型
          System.out.println("");
          A a = new A();//TODO 方法中使用到
          return a;
      }
  }
  
  class A {}
  
  class B {}
  ```



### 2、继承（泛化 Generalization）

![image-20200505174702414](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200505174702414.png)

```java
public class Generalization extends Base {

    @Override
    public void get(Object oId) {

    }

    @Override
    public void put(Object oName) {

    }
}

abstract class Base {
    abstract public void get(Object oId);

    abstract public void put(Object oName);
}
```

### 3、实现（Realization）

**实现关系实际上就是 A类 实现 B接口，依赖关系的特例。**

![image-20200505174744892](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200505174744892.png)

```java
public class Implementation implements Base {
    @Override
    public void init() {
        System.out.println("init");
    }
}

interface Base {
    void init();
}
```

### 4、关联（Association）

**类与类之间的关系，依赖关系的特例。**

**关联具有导航性：即双向关系或单向关系。**

![image-20200505174827128](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200505174827128.png)

```java
public class Person {
    private IDCard idCard;
}

class IDCard {
    //private Person person;
}
```

### 5、聚合（Aggregation）

**表示的是整体和部分的关系，整体与部分可以分开，关联关系的特例。**

**聚合关系是关联关系的特例，所以他具有关联的导航性与多重性。**

![image-20200505174903689](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200505174903689.png)

```java
public class Computer {
    private Mouse mouse;
    private Keyboard keyboard;

    public void setMouse(Mouse mouse) {
        this.mouse = mouse;
    }

    public void setKeyboard(Keyboard keyboard) {
        this.keyboard = keyboard;
    }
}

class Mouse {}

class Keyboard {}
```

### 6、组合（Composite）

**整体与部分的关系，但是整体与部分不可以分开，关联关系的特例。**

**级联删除就是组合关系。**

![image-20200505174939312](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200505174939312.png)

```java
public class Computer {
   private CPU cpu = new CPU();
   private SSD ssd = new SSD();
}

class CPU {}

class SSD {}
```



# 3、单例模式

**单例设计模式 —> 创建型模式**

单例模式，是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。
通过单例模式可以保证系统中，应用该模式的类只有一个实例。**即一个类只有一个对象实例。**

**在java语言中，单例带来了两大好处：**

（1）对于频繁使用的对象（数据源、Session工厂），可以省略创建对象所花费的时间，这对于重量级的对象而言，是非常可观的一笔系统开销。
（2）由于new操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻GC压力，缩短GC停顿时间。

**具体实现**

**需要：**
（1）**将构造方法私有化，使其不能在类的外部通过new关键字实例化该类对象。**
（2）**在该类内部产生一个唯一的实例化对象，并且将其封装为 private static 类型。**
（3）**定义一个静态方法返回这个唯一对象。**

## 实现一：饿汉式 / 静态常量

- **立即加载就是使用类的时候已经将对象创建完毕（不管以后会不会使用到该实例化对象，先创建了）。常见的实现办法就是直接new实例化。**

```java
/**
 * 懒汉单例
 */
class Singleton{
    //构造器私有化
    private Singleton(){
    }
    //类加载时实例化
    private final static Singleton instance = new Singleton();
    //对外提供静态方法
    public static Singleton getInstance(){
        return instance;
    }
}
```

**“饿汉模式”的优缺点：**

- 优点：实现起来简单，**没有多线程同步问题。**
- 缺点：当类 Singleton 被加载的时候，会初始化 static 的 instance，静态变量被创建并分配内存空间，从这以后，这个 static 的 instance 对象便一直占着这段内存，可能造成内存浪费（即便你还没有用到这个实例）。当类被卸载时，静态变量被摧毁，并释放所占有内存，在某些特定条件下会耗费内存。
- 如果方法内有其他 static 方法，调用该方法此类也**会**加载初始

## 实现二：饿汉式 / 静态代码块

```java
//懒汉静态代码块
class Singleton1{
    private static Singleton1 instance;
    private Singleton1(){
    }
    static {
         instance = new Singleton1();
    }
    public static Singleton1 getInstance(){
        return instance;
    }
}
```

## 实现三：懒汉式 / 线程不安全

- **延迟加载就是调用 getInstance() 方法时实例才被创建（先不急着实例化出对象，等要用的时候才创建出来)。常见的实现方法就是在 getInstance() 方法中进行new实例化。**

```java
public class LazyLoadingSingletonThreadUnSafe {
    public static void main(String[] args) {
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1==singleton2);//true
    }
}
//懒汉单例 线程不安全
class Singleton{
    //将自己实例化对象设置为一个属性，用static
    private static Singleton instance;
    //构造方法私有化
    private Singleton(){}

    //静态方法返回实例
    public static Singleton getInstance(){
        if (instance==null){
            //线程在这里被阻塞，则对象没别创建，不安全
            instance = new Singleton();
        }
        return instance;
    }
}
```

**懒汉模式”的优缺点：**

- 优点：实现起来比较简单，当类 Singleton 被加载的时候，静态变量 static 的 instance 未被创建并分配内存空间，当 getInstance() 方法第一次被调用时，初始化instance变量，并分配内存，因此在某些特定条件下会节约了内存。
- 缺点：**在多线程环境中，这种实完现方法是全错误的，不能保证单例的状态。**
- 如果方法内有其他 static 方法，调用该方法此类**不会**加载初始化。

## 实现四：懒汉式 / 线程安全 Sync

- **静态方法返回该实例，加 `Synchronized` 关键字实现同步。**

```java
class Singleton1{
    //将自己实例化对象设置为一个属性，用static
    private static Singleton1 instance;
    //构造方法私有化
    private Singleton1(){}

    //静态方法返回实例，方法加synchronized 关键字
    public static synchronized Singleton1 getInstance(){
        if (instance==null){
            instance = new Singleton1();
        }
        return instance;
    }
}
```

**线程安全的“懒汉模式”（加锁）的优缺点：**

- 优点：在多线程情形下，保证了“懒汉模式”的线程安全。
- 缺点：在多线程情形下，**synchronized方法通常效率低**，显然这不是最佳的实现方案。
- 如果方法内有其他static方法，调用该方法此类**不会**加载初始化。

## 实现五：DCL双检查锁机制

（DCL：Double Checked Locking）

```java
public class LazyLoadingSingletonDCL {
    public static void main(String[] args) {
        Singleton instance = Singleton.getInstance();
        Singleton instance1 = Singleton.getInstance();
        System.out.println(instance==instance1);
    }
}


class Singleton {
    // 将自身实例化对象设置为一个属性，并用 volatile、static 修饰
    private volatile static Singleton instance;

    //构造器私有化
    private Singleton() {
    }

    // 静态方法返回该实例
    public static Singleton getInstance() {
        // 第一次检查instance是否被实例化出来
        if (instance == null) {
            synchronized (Singleton.class) {
                // 某个线程取得了类锁，实例化对象前第二次检查 instance 是否已经被实例化
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

**方法五算是单例模式的最佳实现方式。内存占用率高，效率高，线程安全，多线程操作原子性。**

- 如果方法内有其他 static 方法，调用该方法此类**不会**加载初始化。

## 实现六：静态内部类

```java
class Singleton{
    private Singleton(){}

    public static Singleton getInstance(){
        return SingleHolder.INSTANCE;
    }
    //静态的内部类
    private static class SingleHolder{
        //加载 Singleton 类时并不会加载内部类
        private static final Singleton INSTANCE = new Singleton();
    }
}
```

第一次加载 Singleton 类时并不会加载内部类初始化 Instance，只有第一次调用 getInstance 方法时虚拟机加载 SingletonHolder 并初始化 Instance ，这样不仅能确保线程安全也能保证 Singleton类的唯一性，所以推荐使用静态内部类单例模式。

## JDK 中单例的应用 Runtime 类

```java
public class Runtime {
    private static Runtime currentRuntime = new Runtime();

    public static Runtime getRuntime() {
        return currentRuntime;
    }
	//TODO 私有化构造器
    private Runtime() {}
```

# 4、工厂模式

**工厂设计模式 —> 创建型模式**

**对象都需要创建，如果创建的时候直接 new 该对象，就会对该对象严重耦合**

假如我们要更换对象，所有 new 对象的地方都需要修改一遍，显然违背了软件设计的开闭原则（OCP）。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；

**`工厂模式最大的优点就是：解耦`**

**三种工厂设计模式的使用：**

- **1、简单工厂**
- **2、工厂方法**
- **3、抽象工厂**



## 1、简单工厂设计模式

**定义：一个工厂方法，依据传入的参数，生成对应的产品对象；**

**角色：**

- **1、抽象产品类**
- **2、具体产品类**
- **3、具体工厂 类**

**使用说明：**

- 先将产品类抽象出来，比如，苹果和梨都属于水果。
- 抽象出来一个水果类 Fruit，苹果和梨就是具体的产品类。
- 然后创建一个水果工厂，分别用来创建苹果和梨。

![image-20200506135112303](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200506135112303.png)

抽象水果类

```java

public abstract class Fruit {

    public abstract void getName();
}
```

具体类 苹果

```java
public class Apple extends Fruit {
    @Override
    public void getName() {
        System.out.println("apple");
    }
}
```

具体类 梨

```java
public class Pear extends Fruit {
    @Override
    public void getName() {
        System.out.println("pear");
    }
}
```

水果工厂

```java
public class FruitFactory {
    public Fruit creatFruit(String type) {
        System.out.println("======FruitFactory creatFruit====");
        if (type.equals("apple")) {//生产苹果
            return new Apple();
        } else if (type.equals("pear")) {//生产梨
            return new Pear();
        }
        return null;
    }
}
```

简单工厂的使用

```java
public class simpleFactory {
    public static void main(String[] args) {
        FruitFactory fruitFactory = new FruitFactory();
        Fruit apple = fruitFactory.creatFruit("apple");//获得苹果
        apple.getName();
        Fruit pear = fruitFactory.creatFruit("pear");//获得梨
        pear.getName();
    }
}
```

**一个简单工厂设计模式就完成了，但是有问题。如果我想吃香蕉，想吃橘子。这种方式，每当我想添加一种水果，就必然要修改工厂类，这显然也违反了开闭原则，亦不可取；所以简单工厂只适合于产品对象较少，且产品固定的需求，对于产品变化无常的需求来说不合适；**

## 2、工厂方法设计模式

**定义：将工厂提取成一个接口或抽象类，具体生产什么产品由子类决定。（`具体工厂生产具体类`）**

**角色：**

- **1、抽象产品类**
- **2、具体产品类**
- **3、抽象工厂类**
- **4、具体工厂类**

![image-20200506141253660](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200506141253660.png)

**和上例中一样，产品类抽象出来，此例把工厂类也抽象出来，工厂方法模式将对象的实例化推迟到子类。**

------

**水果抽象类 苹果类和梨类 代码和上例一样**



**抽象工厂类**

```java
public abstract class FruitFactory {
    public abstract Fruit creatFruit();
}
```

**具体工厂 苹果工厂**

```java
public class AppleFactory extends FruitFactory {
    @Override
    public Fruit creatFruit() {
        return new Apple();
    }
}
```

**具体工厂 梨工厂**

```java
public class PearFactory extends FruitFactory {
    @Override
    public Fruit creatFruit() {
        return new Pear();
    }
}
```

 **工厂方法使用**

```java
public class factoryMethod {
    public static void main(String[] args) {
        AppleFactory appleFactory = new AppleFactory();//苹果工厂生产苹果
        Fruit apple = appleFactory.creatFruit();
        apple.getName();
        PearFactory pearFactory = new PearFactory();//梨工厂生产梨
        Fruit pear = pearFactory.creatFruit();
        pear.getName();
    }
}
```

**以上这种方式，虽然解耦了，也遵循了开闭原则，但是问题根本还是没有解决啊，换汤没换药，如果我需要的产品很多的话，需要创建非常多的工厂，所以这种方式的缺点也很明显；**

##  3、抽象工厂设计模式

**定义：为创建一组相关或者是相互依赖的对象提供的一个接口，而不需要指定它们的具体类。**

**角色：**

- **1、抽象产品类**
- **2、具体产品类**
- **3、抽象工厂类**
- **4、具体工厂类**

**抽象工厂和工厂方法的模式基本一样，区别在于，工厂方法是生产一个具体的产品，而抽象工厂可以用来生产一组相同，有相对关系的产品；重点在于一组，一批，一系列。**

------

**举个例子，假如生产 Iphone 手机，Iphone 手机有很多系列，Iphone8、IphoneXS等；假如Apple8生产需要 CPU A11的处理器，LCD屏幕，而 AppleXs 需要 CPU A12 的处理器和 OLED 屏幕；用抽象工厂来实现：**

![image-20200506141638638](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200506141638638.png)

**CPU 抽象类和实现类**

```java
public abstract class Cpu {
    public abstract void run();
}

class A11 extends Cpu{
    @Override
    public void run() {
        System.out.println("A11");
    }
}

class A12 extends  Cpu{
    @Override
    public void run() {
        System.out.println("A12");
    }
}
```

**屏幕 抽象类和实现类**

```java
public abstract class Screen {
    public abstract void isScreen();
}

class LCD extends Screen{
    @Override
    public void isScreen() {
        System.out.println("LCD");
    }
}

class OLCD extends Screen{
    @Override
    public void isScreen() {
        System.out.println("OLCD");
    }
}
```

**手机工厂接口**

```java
public interface PhoneFactory {
    Cpu getCpu();//获得cpu
    Screen getScreen();//获得屏幕

}
```

**手机工厂实现**

```java
public class Iphone8Factory implements PhoneFactory {
    @Override
    public Cpu getCpu() {
        return new A11();
    }

    @Override
    public Screen getScreen() {
        return new OLCD();
    }
}

public class IPhoneXSFactory implements  PhoneFactory {
    @Override
    public Cpu getCpu() {
        return new A12();
    }

    @Override
    public Screen getScreen() {
        return new LCD();
    }
}
```

**抽象工厂使用**

```java
public class abstractFactory {
    public static void main(String[] args) {
        Iphone8Factory iphone8Factory = new Iphone8Factory();
        IPhoneXSFactory iPhoneXSFactory = new IPhoneXSFactory();
        System.out.println("========iphone8Factory==========");
        Cpu cpuA11 = iphone8Factory.getCpu();
        Screen screen = iphone8Factory.getScreen();
        cpuA11.run();
        screen.isScreen();
        System.out.println("========iPhoneXSFactory==========");
        Cpu cpuA12 = iPhoneXSFactory.getCpu();
        Screen screen1 = iPhoneXSFactory.getScreen();
        cpuA12.run();
        screen1.isScreen();
    }
}
```

**以上例子可以看出，抽象工厂可以解决一系列的产品生产的需求，对于大批量，多系列的产品，用抽象工厂可以更好的管理和扩展；**

------

## 三种工厂方式总结

- 1、对于简单工厂和工厂方法来说，两者的使用方式实际上是一样的，如果对于产品的分类和名称是确定的，数量是相对固定的，推荐使用简单工厂模式；
- 2、抽象工厂用来解决相对复杂的问题，适用于一系列、大批量的对象生产；

## JDK 中工厂设计模式的应用 Calendar 类

```java
Calendar.getInstance();

public static Calendar getInstance(){
        return createCalendar(TimeZone.getDefault(), 					                              Locale.getDefault(Locale.Category.FORMAT));
}

public static Locale getDefault(Locale.Category category) {
    // do not synchronize this method - see 4071298
    switch (category) {
        case DISPLAY:
            if (defaultDisplayLocale == null) {
                synchronized(Locale.class) {
                    if (defaultDisplayLocale == null) {
                        defaultDisplayLocale = initDefault(category);
                    }
                }
            }
            return defaultDisplayLocale;
        case FORMAT:
            if (defaultFormatLocale == null) {
                synchronized(Locale.class) {
                    if (defaultFormatLocale == null) {
                        defaultFormatLocale = initDefault(category);
                    }
                }
            }
            return defaultFormatLocale;
        default:
            assert false: "Unknown Category";
    }
    return getDefault();
}


private static Calendar createCalendar(TimeZone zone,Locale aLocale){
    CalendarProvider provider =
        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
        .getCalendarProvider();
    if (provider != null) {
        try {
            return provider.getInstance(zone, aLocale);
        } catch (IllegalArgumentException iae) {
            // fall back to the default instantiation
        }
    }

    Calendar cal = null;

    if (aLocale.hasExtensions()) {
        String caltype = aLocale.getUnicodeLocaleType("ca");
        if (caltype != null) {
            switch (caltype) {
                case "buddhist":
                    cal = new BuddhistCalendar(zone, aLocale);
                    break;
                case "japanese":
                    cal = new JapaneseImperialCalendar(zone, aLocale);
                    break;
                case "gregory":
                    cal = new GregorianCalendar(zone, aLocale);
                    break;
            }
        }
    }
    if (cal == null) {
        // If no known calendar type is explicitly specified,
        // perform the traditional way to create a Calendar:
        // create a BuddhistCalendar for th_TH locale,
        // a JapaneseImperialCalendar for ja_JP_JP locale, or
        // a GregorianCalendar for any other locales.
        // NOTE: The language, country and variant strings are interned.
        if (aLocale.getLanguage() == "th" && aLocale.getCountry() == "TH") {
            cal = new BuddhistCalendar(zone, aLocale);
        } else if (aLocale.getVariant() == "JP" && aLocale.getLanguage() == "ja"
                   && aLocale.getCountry() == "JP") {
            cal = new JapaneseImperialCalendar(zone, aLocale);
        } else {
            cal = new GregorianCalendar(zone, aLocale);
        }
    }
    return cal;
}
```

# 5、适配器模式

**适配器设计模式—> 结构型模式**

**基本介绍**

- **适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)**
- **主要分为三类：类适配器模式、对象适配器模式、接口适配器模式**



**工作原理**

- **适配器模式：将一个类的接口转换成另一种接口，让原本接口不兼容的类可以兼容；**
- **从用户的角度看不到被适配者，是解耦的；**
- **用户调用适配器转化出来的目标接口方法，适配器再调用被适配者的相关接口方法；**
- **用户收到反馈结果，感觉只是和目标接口交互，如图**

![image-20200509153437305](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200509153437305.png)

### 1、类适配器模式

- **Java 是单继承机制，所以类适配器需要继承 Src 类这一点算是一个缺点，因为这要求 Dst 必须是接口，有一定局限性;**
- **Src 类的方法在 Adapter 中都会暴露出来，也增加了使用的成本。**
- **由于其继承了 Src类，所以它可以根据需求重写 Src类的方法，使得Adapter的灵活性增强了。**

**以生活中充电器的例子介绍适配器**

- **充电器本身相当于 Adapter**
- **220V交流电相当于 Src（即被适配者），**
- **5V直流电相当于 Dst（即目标）。**

![image-20200509153504609](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200509153504609.png)

被适配者 Src Class

```java
public class Voltage220V {
    public int output220V(){
        int voltage = 220;
        System.out.println("输出220V");
        return  voltage;
    }
}
```

适配器接口 Dst Class

```java
public interface IVoltage5V {
    public int output5V();
}
```

 适配器 Adapter Class

```java
public class VoltageAdapter extends Voltage220V implements IVoltage5V {
    @Override
    public int output5V() {
        System.out.println("适配器适配电压");
        int srcV = output220V();
        int dscV = srcV/44;
        System.out.println("适配后的电压为"+dscV+"V");
        return dscV;
    }
}
```

Phone Class

```java
public class Phone {
    public void charging(IVoltage5V iVoltage5V) {
        int i = iVoltage5V.output5V();
        if (i == 5) {
            System.out.println("5V电压正在充电");
        } else if (i > 5) {
            System.out.println("电压大于5V，无法充电");
        }
    }
}
```

Client Class

```java
public class Client {
    public static void main(String[] args) {
        Phone phone = new Phone();
        phone.charging(new VoltageAdapter());
    }
}
```

### 2、对象适配器模式

- **基本思路和类的适配器模式相同，其实算是同一种思想，只是将 Adapter 类作修改，不是继承 Src类， 而是持有 Src类的实例，以解决兼容性的问题。即：持有 Src类，实现 Dst类接口，完成 Src —> Dst 的适配；**
- **根据合成复用原则，使用聚合替代继承，所以它解决了类适配器必须继承 Src的局限性问题，也不再要求 Dst必须是接口。使用成本更低，更灵活。**
- **根据 `合成复用原则`，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。对象适配器模式是适配器模式常用的一种；**

![image-20200509155446332](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200509155446332.png)

👉 适配器 Adapter Object

**`由继承变成了聚合`**

```java
public class VoltageAdapter implements IVoltage5V {
    //不使用继承 使用聚合
    private Voltage220V voltage220V;

    public VoltageAdapter(Voltage220V voltage220V) {
        this.voltage220V = voltage220V;
    }

    @Override
    public int output5V() {
        int dscV = 0;
        if (voltage220V != null) {
            System.out.println("适配器适配电压");
            int srcV = voltage220V.output220V();
            dscV = srcV / 44;
            System.out.println("适配后的电压为" + dscV + "V");
            return dscV;
        }
        return dscV;
    }
}

```

### 3、接口适配器模式

- **核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现(空方法)，那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。**
- **适用于一个接口不想使用其所有的方法的情况。**

适配器接口

```java
public interface Interface {
	public void m1();
	public void m2();
	public void m3();
	public void m4();
    public void m5();
}
```

抽象类实现接口 空方法

```java
public class AbsAdapter implements Interface {
    @Override
    public void m1() {
    }
    @Override
    public void m2() {
    }
    @Override
    public void m3() {
    }
    @Override
    public void m4() {
    }
    @Override
    public void m5() {
    }
}
```

Client

```java
public class Client {
    public static void main(String[] args) {
        AbsAdapter absAdapter = new AbsAdapter(){
            @Override
            public void m1() {
                System.out.println("m1");
            }

            @Override
            public void m2() {
                System.out.println("m2");
            }
        };
        absAdapter.m1();
        absAdapter.m2();
        absAdapter.m3();
    }
}

```

**适配器模式的注意事项和细节**

- 三种命名方式，是根据 Src 是以怎样的形式给到 Adapter (在Adapter里的形式) 来命名的。
  - **类适配器：以类给到，在Adapter里，就是将 Src 当做类，继承；**
  - **对象适配器：以对象给到，在Adapter里，将 Src 作为一个对象，持有**
  - **接口适配器：以接口给到，在Adapter里，将 Src 作为一个接口，实现**
- **Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。**

**适配器模式在SpringMVC框架应用**

- **SpringMvc 中的 HandlerAdapter，就使用了适配器模式；**
- **使用 HandlerAdapter 的原因分析：可以看到处理器的类型不同，有多重实现方式，那么调用方式就不是确定的，如果需要直接调用 Controller 方法，需要调用的时候就得不断是使用 if/else 来进行判断是哪一种子类然后执行。那么如果后面要扩展Controller，就得修改原来的代码，这样违背了OCP原则。**

# 6、装饰者模式

- **装饰者模式：动态的将新功能附加到对象上。在功能的扩展方面比继承更有弹性，装饰者模式也体现勒开闭原则（oop）**



## **1、装饰者模式解决星巴克咖啡订单**



- ![image-20200509180110583](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200509180110583.png)

  

饮料抽象类

```java
public abstract class Drink {
    public String description="";//饮料的具体描述
    private float price = 0.0f; //饮料的价格

    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public float getPrice() {
        return price;
    }

    public void setPrice(float price) {
        this.price = price;
    }

    public abstract float cost();//计算价格抽象方法 具体价格具体类实现
}

```

Coffee类

```java
public class Coffee extends Drink {

    @Override
    public float cost() {
        return super.getPrice();
    }
}

```

具体的咖啡：美式咖啡

```java
public class LongBlack extends Coffee {
    public LongBlack() {
        setDescription("LongBlack");
        setPrice(12.0f);
    }
}
```

装饰者：这里是调味品

```java
public class Decorator extends Drink {
    private Drink obj;

    public Decorator(Drink obj){//j通过聚合关系
        this.obj=obj;
    }

    @Override
    public float cost() {
        //自己的价格 加上被装饰者的价格
        return super.getPrice()+obj.cost();
    }

    @Override
    public String getDescription() {
        //装饰者的描述+装饰者的价格+被装饰者的描述
        return super.getDescription()+" "+super.getPrice()+" &&"+obj.getDescription();
    }
}

```

具体调料 巧克力  牛奶

```java
public class Chocolate extends Decorator {

    public Chocolate(Drink obj) {
        super(obj);
        setDescription("巧克力");
        setPrice(2.0f);
    }
}

public class Milk extends  Decorator {

    public Milk(Drink obj) {
        super(obj);
        setDescription("milk");
        setPrice(1.5f);
    }
}
```

客户端使用

```java
public class Client {
    public static void main(String[] args) {
        //点一份LongBlack
        Drink order = new LongBlack();
		//加一份巧克力
        order = new Chocolate(order);
        System.out.println("费用：" + order.cost());
        System.out.println("描述：" + order.getDescription());
        //加一份牛奶
        order = new Milk(order);
        System.out.println("费用：咖啡+巧克力+牛奶" + order.cost());
        System.out.println("描述：" + order.getDescription());

    }
}
```

## 2、jdk io源码

```java
public class jdk {
    public static void main(String[] args) throws Exception {
        //InputStream 是抽象类 类似于Drink
        //FileInputStream是InputStream的子类，类似前面的Coffee
        //FilterInputStream是InputStream的子类， 类似于前面的Decorator 装饰者
        // DataInputStream是FilterInputStream的子类  具体的装饰者，类似前面的Milk
        DataInputStream dis = new DataInputStream(new FileInputStream("D://a.txt"));
        System.out.println(dis.read());
        dis.close();
    }
}
```

# 7、代理模式

**代理设计模式 —> 结构型模式**

**代理模式：为一个对象提供一个替身，以控制对这个对象的访问，可以详细访问某个对象的方法。即通过代理对象访问目标对象，这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能。**

**分类：**

- **静态代理**
- **动态代理（JDK代理、接口代理）— javaassist 字节码操作**
- **CGLib 代理（Code Generation Library，动态代理范畴，在内存动态创建对象，不需要实现接口）**

## 1、静态代理（Static Proxy）

**静态代理在使用时，需要定义接口或者父类，被代理对象(即目标对象)与代理对象一起实现相同的接口或者是继承相同父类。然后通过调用相同的方法来调用目标对象的方法。**

![image-20200511134011262](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200511134011262.png)

定义接口 static

```java
public interface ITeacherDao {
    void teach();
}
```

------

被代理对象 static

```java
public class TeacherDao implements ITeacherDao {
    @Override
    public void teach() {
        System.out.println("老师授课！");
    }
}
```

------

代理对象 static

```java
//静态代理
public class TeacherDaoProxy implements ITeacherDao {

    private TeacherDao target;

    //构造器
    public TeacherDaoProxy(TeacherDao target) {
        this.target = target;
    }

    @Override
    public void teach() {
        System.out.println("代理对象...开始！---> 提前完成一些事情！");
        target.teach();//TODO 执行目标方法
        System.out.println("代理对象...结束！---> 提交");
    }
}
```

------

使用代理对象 static

```java
public class Client {

    public static void main(String[] args) {

        //创建目标，被代理对象
        TeacherDao teacherDao = new TeacherDao();

        //创建 代理对象，同时把被代理对象传给代理对象
        TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDao);

        //通过代理对象的方法，调用被代理对象的方法
        teacherDaoProxy.teach();
    }
}

//TODO
代理对象...开始！---> 提前完成一些事情！
老师授课！
代理对象...结束！---> 提交
```

- **优点：在不修改目标对象的功能前提下，能通过代理对象对目标功能扩展。**
- **缺点：因为代理对象需要与目标对象实现一样的接口，所以会有很多代理类，一旦接口增加方法，目标对象与代理对象都要维护。**

## 2、动态代理

**JDK 动态代理（Dynamic Proxy）**

**动态代理也叫做：JDK代理（反射机制） or 接口代理**

- **代理类所在包：java.lang.reflect.Proxy**
  - JDK 实现代理只需要使用 newProxyInstance方法，但是该方法需要接受三个参数。
- **代理对象，不需要实现接口，但是目标对象(被代理对象)要实现接口，否则不能用动态代理**；
- **代理对象的生成，是利用 JDK 的API，动态的在内存中构建代理对象。**
  - 通过为 Proxy 类指定 ClassLoader 对象和一组 Class<?>[] interfaces来创建动态代理；
  - 通过实现 InvocationHandler 接口创建自己的调用处理器；
  - 通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型；
  - 通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数传入

**定义接口 Dynamic**

```java
public interface ITeachDao {
    void teach();
}

```

**被代理对象 Dynamic**

```java
public class TeachDao implements ITeachDao {
    @Override
    public void teach() {
        System.out.println("teach.....");
    }
}
```

**代理对象 Dynamic**

```java
public class ProxyFactory {
    private Object target;

    public ProxyFactory(Object target) {
        this.target = target;
    }

    public Object getInstance() {
           /*
        public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
         */
        /**
         * 1、ClassLoader loader：指定当前目标对象使用的类加载器，获取加载器的方法固定
         * 2、Class<?>[] interfaces：目标对象实现的接口类型，使用泛型方法确实类型
         * 3、InvocationHandler h：事情处理，执行目标对象的方法时，会触发事件处理器方法，会把当前执行的目标对象方法作为参数传入
         */
        return Proxy.newProxyInstance(target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("动态代理开始");
                        Object invoke = method.invoke(target, args);
                        System.out.println("动态代理结束");
                        return invoke;
                    }
                });
    }
```

**使用代理对象 Dynamic**

```java
public class Client {
    public static void main(String[] args) {
        //创建目标，被代理对象
        ITeachDao teachDao = new TeachDao();
        //给目标对象创建代理对象
        ProxyFactory proxyFactory = new ProxyFactory(teachDao);
        //返回用接口接收，因为只有接口才能保证代理对象和目标对象方法一致
        ITeachDao instance = (ITeachDao) proxyFactory.getInstance();
        instance.teach();

    }
}
```

## 3、CGLib 代理（Code Generation Library）

**CGLib 代理（Code Generation Library）**

**静态代理 和 JDK代理 都要求目标对象是实现一个接口，但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这就是Cglib代理。**

- **`CGLib 代理也叫作子类代理，CGLib可以为一个类创建一个子类，在子类中采用方法拦截的技术拦截所有父类方法的调用并顺势织入横切逻辑`。在内存中构建一个子类对象从而实现对目标对象功能扩展，有些书也将CGLib 代理归属到动态代理。**
- **CGLib 是一个强大的高性能的代码生成包，它可以在运行期扩展 java类 与 实现java接口。它广泛的被许多AOP的框架使用，例如Spring AOP，实现方法拦截。**
- 在AOP编程中如何选择代理模式
  - **目标对象需要实现接口，用JDK代理**；
  - **目标对象不需要实现接口，用CGLib代理**；
- **CGLib包的底层是通过使用字节码处理框架ASM来转换字节码并生成新的类。**

------

**使用**

- **1、需要 CGLib Jar 包；**
- **`2、在内存中动态构建子类，注意代理的类不能为 Final，否则报错。`**
  - **java.lang. llgalArgumentException**
- **`3、目标对象的方法如果为 final/static，那么就不会被拦截，即不会执行目标对象额外的业务方法。`**

![image-20200511162930126](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200511162930126.png)

**引入 Jar 包**

```java
<!--CGLib 动态代理-->
<dependency>
    <groupId>cglib</groupId>
    <artifactId>cglib</artifactId>
    <version>3.1</version>
</dependency>
```

**被代理对象 CGLib**

```java
public class TeacherDao {

    public void teach() {
        System.out.println("老师授课！");
    }

    public String write(String name) {
        System.out.println("name:" + name);
        return "success！";
    }
}
```

------

**代理对象 CGLib**

```java
import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class ProxyFactory implements MethodInterceptor {

    //维护一个目标对象，Object
    private Object target;

    //构造器，对target进行初始化
    public ProxyFactory(Object target) {
        this.target = target;
    }

    //返回一个代理对象，是target对象的代理对象
    public Object getProxyInstance() {
        //1、创建一个工具类
        Enhancer enhancer = new Enhancer();
        //2、设置父类
        enhancer.setSuperclass(target.getClass());
        //3、设置回调函数
        enhancer.setCallback(this);
        //4、创建子类对象，即代理对象
        return enhancer.create();
    }

    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("CGLib 代理！");
        Object invoke = method.invoke(target, objects);
        System.out.println("CGLib 代理结束！");
        return invoke;
    }
}
```

------

**使用代理对象 CGLib**

```java
public class Client {
    public static void main(String[] args) {

        //创建目标，被代理对象
        TeacherDao target = new TeacherDao();

        //创建代理对象，将目标对象传递给代理对象
        TeacherDao proxyInstance = (TeacherDao) new ProxyFactory(target).getProxyInstance();

        System.out.println(proxyInstance.getClass());
        proxyInstance.teach();

    }
}


```

### 代理变体

- 防火墙代理：内网通过代理穿透防火墙，实现对公网的访问。
- 缓存代理：当请求图片文件等资源时，先到缓存代理取，如果取到资源则ok，如果取不到资源，再到公网或者数据库取，然后缓存。
- 远程代理：远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息。
- 安全代理：屏蔽对真实角色的直接访问。
- 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。
- 同步代理：主要使用在多线程编程中，完成多线程间同步工作。

# 8、观察者设计模式

**观察者设计模式 —> 行为型模式**

**观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer。**

**Subject 通知 Observer 变化。**

- **Observer：接收输入**
- **Subject：登记注册、移除和通知**
  - **registerObserver：注册**
  - **removeObserver：移除**
  - **notifyObservers()：通知所有注册用户，可以更新数据，让主动获取，也可以 Subject 时时推送。**

![image-20200511205158698](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200511205158698.png)

**Subject**

```java
public interface Subject {
    void registerObserver(Observer o);

    void removeObserver(Observer o);

    void notifyObserver();
}
```

**Observer**

```java
public interface Observer {
    void update(float temperature,float pressure,float humidity);
}
```

**WeatherData**

```java
public class WeatherData implements Subject {
    private float temperature;
    private float pressure;
    private float humidity;
    private ArrayList<Observer> observers;//观察者集合

    public WeatherData() {
        observers = new ArrayList<Observer>();
    }

    public float getTemperature() {
        return temperature;
    }

    public float getPressure() {
        return pressure;
    }

    public float getHumidity() {
        return humidity;
    }

    public void seData(float temperature, float pressure, float humidity) {
        this.temperature = temperature;
        this.pressure = pressure;
        this.humidity = humidity;
        notifyObserver();//推送所有观察者 数据更新
    }

    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }

    @Override
    public void removeObserver(Observer o) {
        if (observers.contains(o)) {
            observers.remove(o);
        }
    }
	
    //推送所有
    @Override
    public void notifyObserver() {
        for (int i = 0; i < observers.size(); i++) {
            observers.get(i).update(this.temperature, this.pressure, this.humidity);
        }
    }
}
```

**CurrentConditions**

```java
public class CurrentConditions implements Observer {
    private float temperature;
    private float pressure;
    private float humidity;

    //更新数据
    @Override
    public void update(float temperature, float pressure, float humidity) {
        this.temperature = temperature;
        this.pressure = pressure;
        this.humidity = humidity;
        dispaly();
    }
    //展示数据
    private void dispaly() {
        System.out.println("============CurrentConditions data==========");
        System.out.println("today temperature =" + temperature);
        System.out.println("today pressure =" + pressure);
        System.out.println("today humidity=" + humidity);
    }

}



public class OtherCurrentConditions implements Observer {
    private float temperature;
    private float pressure;
    private float humidity;

    //更新数据
    @Override
    public void update(float temperature, float pressure, float humidity) {
        this.temperature = temperature;
        this.pressure = pressure;
        this.humidity = humidity;
        dispaly();
    }
    //展示数据
    private void dispaly() {
        System.out.println("============OtherCurrentConditions data==========");
        System.out.println("today temperature =" + temperature);
        System.out.println("today pressure =" + pressure);
        System.out.println("today humidity=" + humidity);
    }
}
```

**Client**

```java
public class Client {
    public static void main(String[] args) {
        //创建 Subject WeatherData 数据源
        WeatherData weatherData = new WeatherData();
        //创建观察者 Observer
        Observer currentConditions = new CurrentConditions();
        Observer otherCurrentConditions = new OtherCurrentConditions();

        //把观察者注册进 Subject
        weatherData.registerObserver(currentConditions);
        weatherData.registerObserver(otherCurrentConditions);

        System.out.println("========更新数据，并通知观察者========");
        weatherData.seData(20f,20f,133f);


        weatherData.removeObserver(currentConditions);
        System.out.println("=======Remove CurrentConditions=======");
        weatherData.notifyObserver();
    }
}
```

### 观察者模式 JDK 应用源码分析

![image-20200511212249538](https://gitee.com/chen_yi_fenga/blog-imag/raw/master/image-20200511212249538.png)